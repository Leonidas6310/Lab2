## Отчёт по лабораторной работе № 2

#### № группы: `ПМ-2501`

#### Выполнил: `Роднов Леонид Михайлович`

#### Вариант: `20`

---
### Содержание

- [Задание 1](#задание-1)
  - [1. Постановка задачи](#1-постановка-задачи)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных)
  - [4. Алгоритм](#4-алгоритм)
  - [5. Программа](#5-программа)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения)
- [Задание 2](#задание-2)
  - [1. Постановка задачи](#1-постановка-задачи-1)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные-1)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных-1)
  - [4. Алгоритм](#4-алгоритм-1)
  - [5. Программа](#5-программа-1)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения-1)
- [Задание 3](#задание-3)
  - [1. Постановка задачи](#1-постановка-задачи-2)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные-2)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных-2)
  - [4. Алгоритм](#4-алгоритм-2)
  - [5. Программа](#5-программа-2)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения-2)
- [Задание 4](#задание-4)
  - [1. Постановка задачи](#1-постановка-задачи-3)
  - [2. Входные и выходные данные](#2-входные-и-выходные-данные-3)
  - [3. Выбор структуры данных](#3-выбор-структуры-данных-3)
  - [4. Алгоритм](#4-алгоритм-3)
  - [5. Программа](#5-программа-3)
  - [6. Анализ правильности решения](#6-анализ-правильности-решения-3)

---
## Задание 1

### 1. Постановка задачи

- **Условие задачи**
>Ваша задача – посмотреть, какие значения принимает последовательность
> при разных a0 и n, вывести закономерность, по которой строится
> последовательность и запрограммировать ее самостоятельно.

- Необходимо вывести закономерность от разных `a0` и `n` и построить
последовательность в зависимости от `a0` и `n`.

- Для того чтобы вывести закономерность будем вводить разные `a0` и `n`
и изучим получившуюся последовательность.
  - Найдём зависимость от `n`. Для нулевого члена `a0` зададим
  фиксированное число 3.    
  В качестве `n` зададим число 10. Получим
  последовательность:
      ```
      a0 = 3
      n = 10
      0, 0, -3, -12, -15, -60, -63, -252, -255, -1020
      ```
    Далее в качестве `n` зададим число 17. Получим последовательность:
    ```
    a0 = 3
    n = 17
    0, 0, -3, -12, -15, -60, -63, -252, -255, -1020, -1023, -4092, -4095, -16380, -16383, -65532, -65535
    ```
    В итоге, мы получили такую же последовательность. Значит, от `n`
  последовательность не зависит
  - Найдём зависимость от a0. В качестве `n` зададим число 7.  
  Сначала пусть `a0 = 2` - простое число
    ```
    a0 = 2
    n = 7
    -1, -4, -7, -28, -31, -124, -127
    ```
    Прослеживается следующая зависимость. Нечётные элементы на 3 меньше
  предыдущего, а чётные элементы в 4 раза больше предыдущего.  
  Теперь,
  пусть `a0 = 4` - составное число.
    ```
    a0 = 4
    n = 7
    1, 4, 1, 4, 1, 4, 1
    ```
    Получим такую же закономерность.   
  Теперь, пусть `a0 = -2` -
  отрицательное число
    ```
    a0 = -2
    n = 7
    -5, -20, -23, -92, -95, -380, -383
    ```
    Зависимость та же. Таким образом, зависимости от чисел `a0` и `n`
  нет. Число `a0` лишь задаёт начальное значение для последовательности


### 2. Входные и выходные данные

-  #### **Данные на вход**

На вход поступают два числа: `a0` и `n`, принадлежащих, соответственно,
числовым множествам `ℤ` и `ℕ`.

| Число |  Тип  | Нижняя граница |Верхняя граница |
|-------|-------|----------------|----------------|
| a0    |   ℤ   | -2<sup>31<sup> |2<sup>31</sup>-1|
| n     |   ℕ   | 1              |2<sup>31</sup>-1|

- #### **Данные на выход**

Программа будет строить последовательность, которую будем хранить в
списке `arr`.

### 3. Выбор структуры данных

Числа на вход будем хранить в переменной int, так как числа `a0` и `n`
принадлежат множествам целых и натуральных чисел соответственно.

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| a0    | a0                  | int            |
| n     | n                   | int            |

Результатом программы будет список, хранящий, целые числа

| Объект | Название переменной | Тип переменной |
|--------|---------------------|----------------|
| arr    | arr                 | int            |

### 4. Алгоритм

1. Вход данных:     
    Программа на вход получает числа `a0` и `n`, которые сохраняем в
одноимённые переменные.

2. Проверка на ограничение:   
    Число `n` - количество элементов последовательности. Очевидно,
что оно должно быть больше или равно одному. Поэтому, если `n` меньше
одного, то программа выводит ошибку (`Error, n should be greater than 0`)
и завершается.

3. Создаём массив `arr` и заполняем его с помощью цикла по следующему
правилу. Если индекс (номер) элемента нечётный, то такой элемент на 3
меньше предыдущего. Иначе (если индекс элементы чётный), то элемент
в 4 раза больше предыдущего.

4. Вывод на экран:   
    Используя цикл, выводим массив `arr` на экран.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class First {
    // Объявляем объект класса PrinStream для вывода данных
    public static PrintStream out = System.out;
    // Объявляем объект класса Scanner для ввода данных
    public static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {
        // Вводим нулевой элемент последовательности
        int a0 = in.nextInt();
        // Вводим количество элементов последовательности
        int n = in.nextInt();

        // Проверка на ограничения
        if (n < 1) {
            out.print("Error, n should be greater than 0");
            return;
        }

        //Создаём массив, хранящий последовательность
        int[] arr = new int[n];
        for (int i = 1; i < n+1; ++i) {
            // В данном случае i - номер элемента последовательности
            if (i % 2 != 0)
                a0 -= 3;
            else
                a0 *= 4;

            // Индекс элемента массива на 1 меньше, чем номер элемента в последовательности
            arr[i-1] = a0;
        }

        // Вывод на экран
        for (int i = 0; i < n; ++i)
            out.print(arr[i] + " ");
    }
}
```

### 6. Анализ правильности решения

Сверим результаты написанной программы.

1. Тест для `a0 = 2` и `n = 7`
```
Вывод:
-1 -4 -7 -28 -31 -124 -127 
```

2. Тест для `a0 = 4` и `n = 7`
```
Вывод:
1 4 1 4 1 4 1 
```

3. Тест для `a0 = -2` и `n = 7`
```
Вывод:
-5 -20 -23 -92 -95 -380 -383 
```

4. Тест на ограничение для `n`
```
Ввод:
-5 -2
Вывод:
Error, n should be greater than 0
```

Результаты выполнения программы совпадают с исходными данными. Программа
работает корректно

## Задание 2

### 1. Постановка задачи

- **Условие задачи**
>Дана последовательность из n целых чисел. Определите, можно ли
> переставить ее элементы так, чтобы остатки от деления на 3 у любых
> двух соседних элементов различались. Выведите "YES" или "NO".

- Необходимо проверить, можно ли в данной последовательности сделать так,
чтобы любые соседние элементы имели разный остаток от деления на 3.     

- Чтобы проверить этот факт, необходимо узнать, какой остаток 
от деления в данной последовательности встречается чаще всего. Если он
встречается не более, чем половина от размера последовательности, то
такая перестановка элементов возможна.  
    Это легко понять, если проделать такой алгоритм. Взять числа с одним
остатком от деления на 3, который встречается чаще остальных, и поставить
их на нечётные места последовательности (1, 3, 5, ...). Если этих чисел
больше, чем половина всех мест последовательности, то такая перестановка
невозможна, потому что всего нечётных мест - половина от всех мест,
округлённая сверху.

### 2. Входные и выходные данные

**Данные на вход**

На вход мы получаем натуральное число `n` - размер последовательности. А
также n целых чисел `a_n` - элементов последовательности.

| Число |  Тип   | Нижняя граница |Верхняя граница |
|-------|--------|----------------|----------------|
| n     |   ℕ    | 1              |2<sup>31</sup>-1|
| a_n   |   ℤ    | -2<sup>31<sup> |2<sup>31</sup>-1|

**Данные на выход**

Данных на выход нет. На выходе программа выводит сообщения `YES` или `NO`.

### 3. Выбор структуры данных

На вход программа получает целые и натуральные числа, Для их хранения
достаточно использовать тип данных `int`.  

Также программа будет хранить последовательность в списке `arr`, для чего
подойдёт массив целых чисел `int[]` размером `n`.

| Объект | Название переменной                        | Тип переменной |
|--------|--------------------------------------------|----------------|
| n      | n                                          | int            |
| a_n    | нет (значение сразу записывается в список) | int            |
| arr    | arr                                        | int[]          |

Для подсчёта числа элементов, принадлежащих одному классу вычетов по
модулю 3 будем использовать целочисленный массив `modTally`.

| Объект   | Название переменной | Тип переменной |
|----------|---------------------|----------------|
| modTally | modTally            | int[]          |


### 4. Алгоритм

1. Программа получает на вход число `n` и записывает в одноимённую переменную.
2. Создание целочисленного массива `arr` длины `n`.
3. Заполнение массива `arr` целыми числами.
4. Создание целочисленного массива `modTally` длины 3.
5. Циклом проходим по каждому элементу `arr` и добавляем единицу к элементу
`modTally` с номером, соответсвующим классу вычета данного элемента `arr`.
6. Находим максимальное число `modTally` с помощью подпрограммы `max()`.
7. Если максимальное значение не более половины от `n`, округлёноой до верху,
выводим на экран `YES`, иначе - `NO`.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Second {
    public static PrintStream out = System.out;
    public static Scanner in = new Scanner(System.in);

    static int max(int[] arr) {
        int max = 0;
        for (int i = 0; i < arr.length; i++)
            if (arr[i] > max)
                max = arr[i];

        return max;
    }

    public static void main(String[] args) {
        int n = in.nextInt();
        // n должно быть натуральным
        if (n < 1)
            out.print("Error, n should be greater than 0");

        int[] arr = new int[n];
        for (int i = 0; i < n; ++i)
            arr[i] = in.nextInt();

        int[] modTally = {0, 0, 0};
        for (int i = 0; i < n; ++i)
            ++modTally[arr[i]%3];

        //Если максимальное количество чисел от чисел определённого остатка меньше или равно
        //половине (округлённой до верха), то такая перестановка возможна
        if (max(modTally) <= (n+1)/2)
            out.print("YES");
        else
            out.print("NO");
    }
}
```

### 6. Анализ правильности решения

1. Тест на ограничение для `n`:
```
Ввод:
-1
Вывод:
Error, n should be greater than 0
```

Следующие тесты будут для `n = 9`

2. Тест для `1 3 2 2 1 1 1 1 1`
```
Вывод:
NO
```

3. Тест для `1 3 2 2 2 1 1 1 1`
```
Вывод:
YES
```

## Задание 3

### 1. Постановка задачи

- Условие задачи
>На вход подается целое число M (1 ≤ M ≤ 10^15). Выведите наибольшее
> целое k, для которого выполняется неравенство k * k < M.

- Вся задача сводится к поиску квадратного корня числа, при этом, если
`M` является квадратом числа `k`, то `k` необходимо уменьшить на 1,
чтобы выполнялось неравенство.  
    Важным замечанием по поводу алгоритма поиска нужного числа является
то, что числа на числовой оси упорядочены по возрастанию. Значит, можно
пользоваться алгоритмом бинарного поиска

- Алгоритм бинарного поиска в данном случае будет описан в пунтке `4. Алгоритм`

### 2. Входные и выходные данные

**Данные на вход**

На вход подаётся целое число `M` такое, что 1 ≤ M ≤ 10<sup>15<sup>.

| Число |  Тип   |Нижняя граница| Верхняя граница  |
|-------|--------|--------------|------------------|
| M     |   ℕ    |      1       | 10<sup>15<sup>   |

**Данные на выход**

На выходе мы получим число `k`, удовлетворяющее неравенству `k * k < M`,
то есть 1 ≤ k < $\sqrt{10^{15}}$.

| Число |  Тип   |Нижняя граница| Верхняя граница |
|-------|--------|--------------|-----------------|
| k     |   ℕ    |      1       | 31 622 776      |

### 3. Выбор структуры данных

Числа достаточно большие, поэтому число `M` будет храниться в типе данных
`long`. Чтобы не было ошибок, число `k` тоже будет хранить в `long`.

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| M     | M                   | long           |
| k     | k                   | long            |

### 4. Алгоритм

**Бинарный поиск для поиска квадратного корня числа.**

- Смысл метода в том, чтобы за конечное число делений упорядечнного
списка найти нужный элемент. В качестве упорядоченного списка - числовая
ось, левый край которого - ноль: `left = 0`, так как минимальное значение
квадратного корня числа - ноль, а правый конец - число `M`: `right = 0`.

- До тех пор, пока левый конец левее (не более) правого, будем делить
нашу числовую ось на две равные части, и середину будем записывать в переменную
`middle`. Наша цель - найти такую середину `middle`, чтобы она стала 
квадратным корнем числа `M`. Поэтому, если `middle`, оказался больше,
чем $M/middle$ (это равносильно тому, что $middle*middle > M$), то надо
сдвинуть правый конец `right` до числа `middle - 1`, потому что все числа
правее будут так же больше нужного. Иначе, сдвигаем левый конец `left` до
числа `middle + 1`.

- Важным замечанием является то, что в процессе поиска нужно как-то
записать нужный ответ в переменную `k`. Следовательно, нужно добавить условие,
что данный `middle` нам подходит. Если это условие никогда не выполнится
  (если из `M` нельзя "хорошо" извлечь квадратный корень), то наш ответ
будет лежать в левой части числовой оси, потому что корень числа -
иррациональное число (есть знаки после запятой), а `k` - натуральное.
Поэтому числу `k` нужно присвоить значение `middle`, когда мы сдвигаем
левый конец `left`. Связано это с условием того, что `left ≤ right`, и при
сдвиге `left` до `middle + 1`, мы можем завершить цикл, не сохранив ответ в `k`.
  
### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Third {
    public static PrintStream out = System.out;
    public static Scanner in = new Scanner(System.in);

    static long power(int n, int k) {
        long res = 1;
        for (int i = 0; i < k; ++i)
            res *= n;

        return res;
    }

    public static void main(String[] args) {
        long M = in.nextLong();
        if (M < 1 || M > power(10, 15))
            out.print("Error, M should be between 1 and 10^15");

        //Заметим, что все числа на числовой оси упорядочены, значит,
        //можно воспользоваться методом бинарного поиска
        long left = 0, right = M;
        long middle;
        long k = -1;
        while (left <= right) {
            middle = (left + right) / 2;
            //Так как, если число M слишком большое, а операция middle*middle
            //может выйти за границы long, то условие можно переписать так:
            if (middle == M / middle) {
                k = middle;
                break;
            }
            else {
                if (middle > M / middle)
                    right = middle - 1;
                else {
                    left = middle + 1;
                    k = middle;
                }
            }
        }

        // Если M - квадрат числа k, то k надо уменьшить на 1
        if (k * k == M)
            --k;

        out.print(k);
    }
}

```

### 6. Анализ правильности решения

1. Возьмём такое `M`, чтобы `k * k = m`
```
Ввод:
256
Вывод:
15
```
Действительно, `15 * 15 < 256`, а `16 * 16 >= 256`.

2. Возьмём большое `M`
```
Ввод:
874673655876
Вывод:
935239
```
Действительно, посчитав на калькуляторе, получим: $\sqrt{874673655876} =
935239,89215..$ Таким образом `935239` правильный ответ

3. Тест на ограничение `M`
```
Ввод:
-1
Вывод:
Error, M should be between 1 and 10^15
```

```
Ввод:
8746736558760000
Вывод:
Error, M should be between 1 and 10^15
```

## Задание 4

### 1. Постановка задачи

- **Условие задачи**
>Проверить, есть ли три элемента, расстояние между любыми двумя из
> которых не превышает k, а значения совпадают. Выведите само значение
> и индексы элементов, если такие элементы существуют, или "NO",
> если их нет.

- Расстояние между любыми двумя элементами можно понимать, как расстояние
между двумя крайними элементами. Тогда решение задачи сводится к поиску трёх
равных элементов в окрестности элементов от `i`-го до (`i+k`)-го, при этом
`i`-й элемент является сравниваемым числом.

### 2. Входные и выходные данные

**Данные на вход**

На вход поступают натуральные числа `n` и `k`, а также `n` целых чисел `a_n` -
элементы массива.

| Число | Тип | Нижняя граница  |Верхняя граница |
|-------|-----|-----------------|----------------|
| n     | ℕ   | 3               |2<sup>31</sup>-1|
| k     | ℕ   | 3               |2<sup>31</sup>-1|
| a_n   | ℤ   | -2<sup>31<sup>  |2<sup>31</sup>-1|

**Данные на выход**

Программа будет выводить сообщения `NO`, а также индексы элементов
массива, если условие задачи выполняются.

| Число | Тип | Нижняя граница | Верхняя граница |
|-------|-----|----------------|-----------------|
| ind1  | ℤ   | 0              | n-3             |
| ind2  | ℤ   | 1              | n-2             |
| ind3  | ℤ   | 2              | n-1             |

### 3. Выбор структуры данных

Натуральные числа `n` и `k` будем хранить в одноимённых переменных типа `int`.

Элементы массива будет хранить в целочисленном `int[]` массиве `arr`.

| Объект | Название переменной               | Тип переменной |
|--------|-----------------------------------|----------------|
| n      | n                                 | int            |
| k      | k                                 | int            |
| a_n    | нет (сразу сохраняется в массив)  | int            |
| arr    | arr                               | int[]          |

Индексы элементов массива, подходящих условию задачи также будем хранить в
одноимённых переменных типа `int`

| Объект | Название переменной | Тип переменной |
|--------|---------------------|----------------|
| ind1   | ind1                | int            |
| ind2   | ind2                | int            |
| ind3   | ind3                | int            |

### 4. Алгоритм

- Получив на вход числа `n` и `k`, програма создаёт массив `arr` длины n и
заполняет его целыми числами.

- Создаются переменные `ind1 = 0`, `ind2 = -1` и `ind3 = -1`. Первый индекс
определён, так как хотя бы один элемент точно попадает под условие задачи.
Если индекс равен `-1` будем говорить, что индекс не определён.

- Циклом по `i` будем проходить по каждому элементу массива. Циклом по `j`
будем определять окрестность элементов от `arr[i]` до `arr[i+k]` с
предположением, что крайние элементы - максимально удалённые возможные равные элементы,
расстояние между которыми k. Тогда, если между ними есть третий равный элемент,
то выполняется условие, что между любыми тремя - расстояние не превышает k.

- Таким образом, сравнивая элементы `arr[i]` и `arr[j]`, будут определены индексы
`ind1`, `ind2` и `ind3`. В случае, если последний индекс определён, то можно закончить
сравнение и выйти из цикла.

- Критерием того, что такие элементы есть, будет то, что `ind3` определён, то есть
не равен `-1`, исходя из предыдущего соображения.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Forth {
    public static PrintStream out = System.out;
    public static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {
        int n = in.nextInt();
        if (n < 3)
            out.print("Error, n should be greater than or equal to 3");
        
        int k = in.nextInt();
        if (k < 3)
            out.print("Error, k should be greater than or equal to 3");
        
        int[] arr = new int[n];
        for (int i = 0; i < n; ++i)
            arr[i] = in.nextInt();

        int ind1 = 0, ind2 = -1, ind3 = -1;
        for (int i = 0; i < n - 2; ++i) {
            //В качестве сравниваемого значения будем брать i-й элемент
            ind1 = i;

            boolean elementsFound = false;
            //Расстояние между первым и последним подходящим элементом должно быть не более k,
            //поэтому в условии цикла указано j < i+k
            for (int j = i+1; j < n && j < i+k; ++j) {
                if (arr[ind1] == arr[j]) {
                    if (ind2 == -1)
                        ind2 = j;
                    else {
                        ind3 = j;
                        elementsFound = true;
                        break;
                    }
                }
            }

            if (elementsFound)
                break;
        }

        if (ind2 != -1 && ind3 != -1)
            out.printf("Значение: %d\nИндексы элементов: %d %d %d", arr[ind1], ind1, ind2, ind3);
        else
            out.print("NO");
    }
}

```

### 6. Анализ правильности решения

1. Тест на ограничение `n`:
```
Ввод:
2 4
Вывод:
Error, n should be greater than or equal to 3
```

2. Тест на ограничение `k`:
```
Ввод:
7 0
Вывод:
Error, n should be greater than or equal to 3
```

3. Тест для `NO`:
```
Ввод:
15 3
4 8 9 3 3 2 0 4 2 2 4 0 1 1 2
Вывод:
NO
```

4. Тест с благоприятным исходом:
```
Ввод:
15 3
4 8 9 3 3 2 0 4 2 2 4 0 1 1 1
Вывод:
Значение: 1
Индексы элементов: 12 13 14
```
